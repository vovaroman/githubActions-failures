name: Failure and Recovery Improved

on:
  push:
    branches:
      - main  # or your default branch
  workflow_dispatch:  # Allows manual trigger for demonstration

jobs:
  failing-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Simulate a failure (exit code 1)
        run: |
          echo "This step is designed to fail."
          exit 1

      - name: This step will be skipped because of previous failure
        run: echo "This step won't run."

  recovery-job:
    runs-on: ubuntu-latest
    needs: failing-job  # Depends on the failing-job
    if: ${{ always() }}  # Run this job even if previous job fails
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check the outcome of the failing-job
        run: |
          if [ "${{ needs.failing-job.result }}" == "failure" ]; then
            echo "The 'failing-job' failed, initiating recovery actions."
          else
            echo "The 'failing-job' was successful (or skipped, or cancelled)."
          fi

      - name: Simulate recovery or notification (runs only if the failing-job failed)
        if: ${{ needs.failing-job.result == 'failure' }}  # Only run if the previous job failed
        run: |
          echo "Performing recovery actions:  e.g. sending alert, rolling back, re-deploying previous version"
          # Add actual recovery steps here (e.g., call a script, use another action)
          echo "Recovery actions completed."

  continue-on-error-job:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Step designed to fail, but continue workflow execution
        id: flaky_step  #  Assign an ID to the step
        continue-on-error: true  #  Allow subsequent steps to run even if this fails
        run: |
          echo "This step might fail (simulate a flaky test or intermittent issue)."
          # Simulate intermittent failure (e.g., 50% chance of failure)
          if (( RANDOM % 2 == 0 )); then
            echo "Simulated failure: exit 1"
            exit 1
          else
            echo "Simulated success: exit 0"
          fi

      - name:  Execute  after a potentially failing step (check outcome)
        run: |
          if [ "${{ steps.flaky_step.outcome }}" == "failure" ]; then  #  Check the outcome of the flaky_step
            echo "The 'flaky_step' failed, but the workflow continued. Proceeding with analysis."
          else
            echo "The 'flaky_step' passed. Continuing as normal."
          fi

      - name:  Always run this step, regardless of previous step's success or failure
        run: echo "This step will always run."
